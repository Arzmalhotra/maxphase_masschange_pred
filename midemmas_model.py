# -*- coding: utf-8 -*-
"""midemmas_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nzc0SJme3hngeyU1LIRN3WtaWHc_mJ12
"""

from google.colab import drive
drive.mount('/content/gdrive')

import numpy as np
import pandas as pd

def del_h(a,b):
    d_h=pd.read_csv('/content/gdrive/MyDrive/max_phase/del_h_data.csv')
    row_number=d_h.index[d_h['0'] == b]
    raw=d_h.loc[row_number,a]

    return(raw*np.power(10,3))

def wt(element):
  wt=pd.read_csv('/content/gdrive/MyDrive/max_phase/weight.csv')
  row_number=wt.index[wt['element'] == element]
  raw=wt.iloc[row_number,1]

  return(raw/np.power(10,3))

def vol(element):
    volume=pd.read_csv('/content/gdrive/MyDrive/max_phase/volume.csv')
    row_number=volume.index[volume['element'] == element]
    raw=volume.iloc[row_number,2]

    return raw/np.power(10,6)

def nu(element):
    nu=pd.read_csv('/content/gdrive/MyDrive/max_phase/volume.csv')
    row_number=nu.index[nu['element'] == element]
    raw=nu.iloc[row_number,1]

    return raw

def bulk_mod(element):
    k_data=pd.read_csv('/content/gdrive/MyDrive/max_phase/k-data.csv')
    row_number=k_data.index[k_data['element'] == element]
    raw=k_data.iloc[row_number,1]
    ##in 10**10
    return (raw)

def func(C_a,a,b):
    V_a = float(vol(a).iloc[0])
    V_b = float(vol(b).iloc[0])
    C_b=1-C_a
    C_S_a = (C_a * np.power(V_a, 2/3)) / (C_a * np.power(V_a, 2/3) + C_b * np.power(V_b, 2/3))
    C_S_b = (C_b * np.power(V_b, 2/3)) / (C_a * np.power(V_a, 2/3) + C_b * np.power(V_b, 2/3))

    gamma = 0
    f_ab_sol = C_S_b * (1 + gamma * (np.power(C_S_a * C_S_b, 2)))
    f_ba_sol = C_S_a * (1 + gamma * (np.power(C_S_a * C_S_b, 2)))
    del_h_mm = C_a * C_b * (f_ab_sol * float(del_h(a, b).iloc[0]) + f_ba_sol * float(del_h(b, a).iloc[0]))

    ##del_h_esh=(2*nu(b)*(V_a-V_b)*(V_a-V_b))/(3*V_b+4*nu(b)*k(a)*V_a)
    del_h_solid=(del_h_mm)

    return(del_h_solid)

a = input('Enter element 1 name: ')
b = input('Enter element 2 name: ')
c = input('Enter element 3 name: ')

m_a=(float)(input('moles per molecule of '+ a +' ' ))
m_b=(float)(input('moles per molecule of '+ b +' '))
m_c=(float)(input('moles per molecule of '+ c +' '))

X_a=float((m_a*wt(a).iloc[0]))/(float(m_a*wt(a).iloc[0])+float(m_b*wt(b).iloc[0])+float(m_c*wt(c).iloc[0]))
X_b=float((m_b*wt(b).iloc[0]))/(float(m_a*wt(a).iloc[0])+float(m_b*wt(b).iloc[0])+float(m_c*wt(c).iloc[0]))
X_c=1-X_a-X_b

import sympy as sp
p1,p2,p3 = sp.symbols("p1,p2,p3", real=True)
C_a= round(X_a/(X_b+X_a),3)

C_b= round(X_b/(X_b+X_c),3)
C_c= round(X_c/(X_a+X_c),3)

del_h_mm=[]
del_h_mm.append(func(C_a,a,b))
del_h_mm.append(func(C_b,b,c))
del_h_mm.append(func(C_c,c,a))

import sympy as sp
p1 = sp.symbols('p1')
p2 = sp.symbols('p2')
p3 = sp.symbols('p3')

result=[]
#result stores the del_h formation values for the ternary subjected to the equation p1+p2+p3=1
cata=[]
#cata stores the values of p1 with respect to every combination of p1,p2,p3 for every del_h value of the system
cata_2=[]
#cata_2 stores the values of p2 with respect to every combination of p1,p2,p3 for every del_h value of the system
eq=p1*del_h_mm[0]+p2*del_h_mm[1]+p3*del_h_mm[2]
#eq is the equation of del_h of the ternary system that has to be minimized

for dum_1 in np.arange(0,1.01,0.01):
    for dum_2 in np.arange(0, 1.01-dum_1, 0.01):
        del_h_final = eq.subs(p1, dum_1)
        del_h_final = del_h_final.subs(p2, dum_2)
        del_h_final = del_h_final.subs(p3, 1-(dum_1+dum_2))
        result.append(del_h_final)
        cata.append(dum_1)
        cata_2.append(dum_2)

final=[]

#checking which of the possible combinations of p1,p2,p3 satisfy the 3 mass balance eqnsCu
#final stores the values of the indexes of the lists that gives all possible values of p1 and p2 , that satisfy the 3 constraint eqns
for iter in range (0,len(result)):
    if(abs(cata[iter]*C_a+((1-cata[iter]-cata_2[iter])*(1-C_c))-X_a)<=0.02):
       if (abs(cata_2[iter]*C_b+(cata[iter]*(1-C_a))-X_b)<=0.02) :
           if (abs((1-cata[iter]-cata_2[iter])*C_c+(cata_2[iter]*(1-C_b))-X_c)<=0.02):
               final.append(iter)
#0.02 error margin has been kept to be sure of the accuracy of the model

min=result[final[0]]
#we initialized the minimum del_h of the ternary system to be the first value of all the shortlisted possible del_h values
for i in range(0,len(final)):
    if result[final[i]]<min:
        min=result[final[i]]
#we obtained the minimum of all the possible del_h values of the ternary system

#printing the final answer
print('the del_h of the ternary system is : ',round(min,3))

